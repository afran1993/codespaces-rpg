üõ†Ô∏è Dettagli Tecnici per le 320 Armi

    Flyweight Pattern: Anche qui, i dati pesanti (descrizioni, icone, ID attacchi) risiedono in items_db.json. L'oggetto Weapon contiene solo lo stato attuale (durabilit√†, rune).

    Sinergia Elementale: Se un'arma viene usata in un nodo della mappa con elemento Alchimia, la probabilit√† di riparazione critica aumenta del 20%.

    Visualizzazione Verticale: La classe GearManager limita l'equipaggiamento attivo. In uno smartphone, mostrare 320 armi insieme √® impossibile; il manager gestisce il caricamento a "scorrimento" (paging).


---

import math

class Weapon:
    """
    Rappresenta un'istanza di un'arma tra le 320 disponibili.
    Include logica di durabilit√† (Entropia) e scaling.
    """
    def __init__(self, weapon_id, data, quality_modifier=1.0):
        self.id = weapon_id
        self.name = data["name"]
        self.base_damage = data["base_damage"]
        self.weapon_type = data["type"] # Es: Spada, Bastone, Arco
        
        # Statistiche influenzate dalla qualit√† (D20 al momento del drop)
        self.damage = math.floor(self.base_damage * quality_modifier)
        
        # Sistema di durabilit√† (Meccanica di Entropia)
        self.max_durability = data["durability"]
        self.current_durability = self.max_durability
        
        # Mapping dei 5 attacchi (ID riferiti alla futura classe AttackSystem)
        self.attack_ids = data["attack_ids"] # Lista di 5 ID
        
        # Slot per Alchimia (Potenziamenti)
        self.runes = []
        self.is_broken = False

    def apply_wear(self, amount):
        """Riduce la durabilit√†. Se arriva a 0, l'arma √® inutilizzabile."""
        self.current_durability -= amount
        if self.current_durability <= 0:
            self.current_durability = 0
            self.is_broken = True

    def repair(self, amount):
        """Ripara l'arma (Meccanica Alchemica)."""
        self.current_durability = min(self.max_durability, self.current_durability + amount)
        if self.current_durability > 0:
            self.is_broken = False

    def get_effective_damage(self):
        """L'arma infligge meno danno se √® quasi rotta."""
        if self.is_broken:
            return 1
        condition_ratio = self.current_durability / self.max_durability
        return self.damage if condition_ratio > 0.2 else math.floor(self.damage * 0.5)

class GearManager:
    """
    Fabbrica e gestore per le 320 armi del gioco.
    """
    def __init__(self, dice_engine):
        self.dice = dice_engine
        self.inventory_limit = 16 # Ottimizzato per UI verticale

    def generate_weapon(self, weapon_id, global_gear_db):
        """
        Crea un'arma dal DB applicando un tiro di dado per la qualit√†.
        """
        base_data = global_gear_db.get(weapon_id)
        if not base_data:
            return None

        # Tiro D20 per determinare la fattura dell'arma (Quality)
        roll = self.dice.roll()
        
        # Modificatore qualit√†: Critico (20) = 1.5x, Fallimento (1) = 0.5x
        if roll["is_crit"]:
            quality = 1.5
        elif roll["is_fail"]:
            quality = 0.5
        else:
            quality = 1.0 + (roll["raw"] / 40.0) # Range tra 1.0 e 1.45

        return Weapon(weapon_id, base_data, quality)